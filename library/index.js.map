{
  "version": 3,
  "sources": ["index.ts"],
  "sourcesContent": [
    "/**\n * @module minimix\n *\n * A powerful TypeScript mixin library that enables multiple inheritance and composition\n * of classes while maintaining proper type safety and prototype chain integrity.\n *\n * This module provides utilities for:\n * - Creating mixins from multiple constructors\n * - Preserving static properties and methods\n * - Maintaining proper prototype chains\n * - Type-safe composition of classes\n *\n * @example\n * ```typescript\n * class A { a() { return 'a'; } }\n * class B { b() { return 'b'; } }\n * const Mixed = Mix(A, B);\n * const instance = new Mixed();\n * instance.a(); // 'a'\n * instance.b(); // 'b'\n * ```\n */\n\n/**\n * Type representing a constructor function that can be either concrete or abstract\n */\ntype Constructor =\n\t| (new (\n\t\t\t...parameters: any[]\n\t  ) => any)\n\t| (abstract new (\n\t\t\t...parameters: any[]\n\t  ) => any);\n\nexport const mixOf = Symbol(\"mixOf\");\n\n/**\n * Type representing the static values of a type T\n */\ntype StaticValues<T> = {\n\t[K in keyof T]: T[K];\n};\n\n/**\n * Utility type that converts a union type to an intersection type\n */\ntype UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (\n\tk: infer I,\n) => void\n\t? I\n\t: never;\n\n/**\n * Converts a tuple of types to their intersection\n */\ntype TupleToIntersection<T extends any[]> = UnionToIntersection<T[number]>;\n\n/**\n * Gets the static values of a tuple of constructors\n */\ntype StaticValuesOf<T extends Array<any>> = TupleToIntersection<{\n\t[K in keyof T]: StaticValues<T[K]>;\n}>;\n\n/**\n * Creates a new class that mixes multiple constructors together\n * @param firstConstructor - The base constructor to extend\n * @param constructors - Additional constructors to mix in\n * @returns A new constructor that combines all input constructors\n */\nexport function Mix<Constructors extends Array<Constructor>>(\n\t...constructors: Constructors\n): (new (\n\t...parameters: {\n\t\t[K in keyof Constructors]: ConstructorParameters<Constructors[K]>;\n\t}\n) => TupleToIntersection<{\n\t[K in keyof Constructors]: InstanceType<Constructors[K]>;\n}>) &\n\tStaticValuesOf<Constructors> {\n\tconst firstConstructor = constructors[0];\n\n\tif (!firstConstructor) {\n\t\treturn class {} as any;\n\t}\n\n\tif (constructors.length === 1) {\n\t\treturn firstConstructor as any;\n\t}\n\n\t// biome-ignore lint/style/noNonNullAssertion: We checked the length of the array the line before\n\tconst lastConstructor = constructors.at(-1)!;\n\n\t/* ---------------------- 1. Build the prototype chain ---------------------- */\n\tconst clone = clonePrototypeDeep(firstConstructor.prototype);\n\tconst { prototype } = clone;\n\tlet { lastPrototype } = clone;\n\n\tfor (const nextConstructor of constructors.slice(1)) {\n\t\tObject.setPrototypeOf(\n\t\t\tlastPrototype,\n\t\t\tclonePrototypeDeep(nextConstructor.prototype).prototype,\n\t\t);\n\t\tlastPrototype = Object.getPrototypeOf(lastPrototype);\n\t}\n\tObject.setPrototypeOf(lastPrototype, lastConstructor.prototype);\n\n\t/* ------ 2. Create the constructor that compose all other constructors ----- */\n\tconst create: any = class extends firstConstructor {\n\t\tstatic [mixOf] = constructors;\n\n\t\tconstructor(...parameters: any[]) {\n\t\t\tif (parameters.length) {\n\t\t\t\tsuper(...parameters[0]);\n\t\t\t} else {\n\t\t\t\tsuper();\n\t\t\t}\n\n\t\t\tparameters.slice(1).forEach((nextParameters, index) => {\n\t\t\t\tObject.assign(\n\t\t\t\t\tthis,\n\t\t\t\t\tnew (constructors[index + 1] as any)(...nextParameters),\n\t\t\t\t);\n\t\t\t});\n\t\t}\n\t};\n\n\t/* ---------------------- 3. Assign the prototype chain --------------------- */\n\tObject.setPrototypeOf(create.prototype, prototype);\n\n\t/* ----------------------- 4. assign static properties ---------------------- */\n\tfor (const nextConstructor of constructors) {\n\t\tObject.assign(create, nextConstructor);\n\t}\n\n\treturn create;\n}\n\n/**\n * Creates a shallow clone of a prototype object\n * @param prototype - The prototype object to clone\n * @returns A new object with the same properties as the input prototype\n */\nfunction clonePrototype(prototype: any) {\n\tconst clone = Object.create(\n\t\tnull,\n\t\tObject.getOwnPropertyDescriptors(prototype),\n\t);\n\tclone.constructor = prototype.constructor;\n\n\tconst originalInstanceOf = prototype.constructor[Symbol.hasInstance] as\n\t\t| ((value: any) => boolean)\n\t\t| undefined;\n\n\tObject.defineProperty(prototype.constructor, Symbol.hasInstance, {\n\t\tvalue: (instance: any) => {\n\t\t\treturn originalInstanceOf?.(instance) || hasPrototype(instance, clone);\n\t\t},\n\t\tenumerable: false,\n\t\tconfigurable: true,\n\t\twritable: true,\n\t});\n\n\treturn clone;\n}\n\n/**\n * Checks if an instance has a specific prototype in its prototype chain\n * @param instance - The instance to check\n * @param prototype - The prototype to look for\n * @returns True if the prototype is found in the instance's prototype chain\n */\nfunction hasPrototype(instance: any, prototype: any) {\n\tlet currentInstancePrototype = Object.getPrototypeOf(instance);\n\n\twhile (currentInstancePrototype) {\n\t\tif (currentInstancePrototype === prototype) {\n\t\t\treturn true;\n\t\t}\n\t\tcurrentInstancePrototype = Object.getPrototypeOf(currentInstancePrototype);\n\t}\n\n\treturn false;\n}\n\n/**\n * Creates a deep clone of a prototype object, including its entire prototype chain\n * @param prototype - The prototype object to clone\n * @returns An object containing the cloned prototype and its last prototype in the chain\n */\nfunction clonePrototypeDeep(prototype: object) {\n\tconst clone = clonePrototype(prototype);\n\tlet lastPrototype = clone;\n\tlet nextPrototype = Object.getPrototypeOf(prototype);\n\twhile (nextPrototype && nextPrototype !== Object.prototype) {\n\t\tconst nextPrototypeClone = clonePrototype(nextPrototype);\n\t\tObject.setPrototypeOf(lastPrototype, nextPrototypeClone);\n\t\tnextPrototype = Object.getPrototypeOf(nextPrototype);\n\t\tlastPrototype = nextPrototypeClone;\n\t}\n\treturn { prototype: clone, lastPrototype };\n}\n"
  ],
  "mappings": "AAkCO,IAAM,EAAQ,OAAO,OAAO,EAoC5B,SAAS,CAA4C,IACxD,EAQ0B,CAC7B,IAAM,EAAmB,EAAa,GAEtC,IAAK,EACJ,OAAO,KAAM,CAAC,EAGf,GAAI,EAAa,SAAW,EAC3B,OAAO,EAIR,IAAM,EAAkB,EAAa,GAAG,EAAE,EAGpC,EAAQ,EAAmB,EAAiB,SAAS,GACnD,aAAc,GAChB,iBAAkB,EAExB,QAAW,KAAmB,EAAa,MAAM,CAAC,EACjD,OAAO,eACN,EACA,EAAmB,EAAgB,SAAS,EAAE,SAC/C,EACA,EAAgB,OAAO,eAAe,CAAa,EAEpD,OAAO,eAAe,EAAe,EAAgB,SAAS,EAG9D,IAAM,EAAc,cAAc,CAAiB,QAC1C,GAAS,EAEjB,WAAW,IAAI,EAAmB,CACjC,GAAI,EAAW,OACd,MAAM,GAAG,EAAW,EAAE,EAEtB,WAAM,EAGP,EAAW,MAAM,CAAC,EAAE,QAAQ,CAAC,EAAgB,IAAU,CACtD,OAAO,OACN,KACA,IAAK,EAAa,EAAQ,GAAW,GAAG,CAAc,CACvD,EACA,EAEH,EAGA,OAAO,eAAe,EAAO,UAAW,CAAS,EAGjD,QAAW,KAAmB,EAC7B,OAAO,OAAO,EAAQ,CAAe,EAGtC,OAAO,EAQR,SAAS,CAAc,CAAC,EAAgB,CACvC,IAAM,EAAQ,OAAO,OACpB,KACA,OAAO,0BAA0B,CAAS,CAC3C,EACA,EAAM,YAAc,EAAU,YAE9B,IAAM,EAAqB,EAAU,YAAY,OAAO,aAaxD,OATA,OAAO,eAAe,EAAU,YAAa,OAAO,YAAa,CAChE,MAAO,CAAC,IAAkB,CACzB,OAAO,IAAqB,CAAQ,GAAK,EAAa,EAAU,CAAK,GAEtE,WAAY,GACZ,aAAc,GACd,SAAU,EACX,CAAC,EAEM,EASR,SAAS,CAAY,CAAC,EAAe,EAAgB,CACpD,IAAI,EAA2B,OAAO,eAAe,CAAQ,EAE7D,MAAO,EAA0B,CAChC,GAAI,IAA6B,EAChC,MAAO,GAER,EAA2B,OAAO,eAAe,CAAwB,EAG1E,MAAO,GAQR,SAAS,CAAkB,CAAC,EAAmB,CAC9C,IAAM,EAAQ,EAAe,CAAS,EAClC,EAAgB,EAChB,EAAgB,OAAO,eAAe,CAAS,EACnD,MAAO,GAAiB,IAAkB,OAAO,UAAW,CAC3D,IAAM,EAAqB,EAAe,CAAa,EACvD,OAAO,eAAe,EAAe,CAAkB,EACvD,EAAgB,OAAO,eAAe,CAAa,EACnD,EAAgB,EAEjB,MAAO,CAAE,UAAW,EAAO,eAAc",
  "debugId": "5C2DE675BCF6363564756E2164756E21",
  "names": []
}